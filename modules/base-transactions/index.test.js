import { BaseTransactions } from './index.js';
import prisma from '../database/database.module.js';
import Sinon from 'sinon';
import { PendingTransactionAssignments } from '../pending-transaction-assignments/pending-transaction-assignments.module.js';

describe('BaseTransactions', () => {
	// Tests that registerManualTransactions successfully registers a manual transaction with valid data
	it('should successfully register a manual transaction with valid data', async () => {
		// Mock the database methods
		const paymentMethod = { id: 1 };
		const category = { id: 1 };
		const transaction = { id: 1 };

		prisma.paymentMethod.findUnique = Sinon.stub().resolves(paymentMethod);
		prisma.transaction.create = Sinon.stub().resolves(transaction);
		prisma.category.findUnique = Sinon.stub().resolves(category);

		// Call the registerManualTransactions method
		const data = [
			'amount=100;',
			'desc=My description;',
			'method=Mercantil Venezuela;',
			'type=debit;',
			'cat=Entertaiment',
		];
		await BaseTransactions.registerManualTransactions(data);

		Sinon.assert.calledOnce(prisma.paymentMethod.findUnique);
		Sinon.assert.calledOnce(prisma.transaction.create);
		Sinon.assert.calledOnce(prisma.category.findUnique);
	});

	// Tests that registerManualTransactions successfully registers a manual transaction with minimum data (amount, payment method, type, category)
	it('should successfully register a manual transaction with minimum data', async () => {
		// Mock the database methods
		const paymentMethod = { id: 1 };
		const category = { id: 1 };
		const transaction = { id: 1 };

		prisma.paymentMethod.findUnique = Sinon.stub().resolves(paymentMethod);
		prisma.transaction.create = Sinon.stub().resolves(transaction);
		prisma.category.findUnique = Sinon.stub().resolves(category);

		// Call the registerManualTransactions method
		const data = [
			'amount=100;',
			'desc=My description;',
			'method=Mercantil Venezuela;',
			'type=debit;',
			'cat=Entertaiment',
		];
		const result = await BaseTransactions.registerManualTransactions(data);

		// Check the result
		expect(result).toEqual(transaction);

		Sinon.assert.calledOnce(prisma.paymentMethod.findUnique);
		Sinon.assert.calledOnce(prisma.transaction.create);
		Sinon.assert.calledOnce(prisma.category.findUnique);
	});
});

// Generated by CodiumAI

describe('registerManualTransactions', () => {
	// Tests that the method creates a transaction with all required fields
	it('should create a transaction with all required fields', async () => {
		// Arrange
		const data = [
			'amount=100;',
			'desc=My description;',
			'method=Mercantil Venezuela;',
			'type=debit;',
			'cat=ENTERTAIMENT',
		];
		const transaction = { id: 1, amount: 100, description: 'My description', type: 'debit' };

		// uses sinon to mock the database methods
		prisma.transaction.create = Sinon.stub().resolves(transaction);
		prisma.dailyExchangeRate.findFirst = Sinon.stub().resolves(null);
		prisma.paymentMethod.findUnique = Sinon.stub().resolves({ id: 1 });
		prisma.category.findUnique = Sinon.stub().resolves({ id: 1 });
		// Act
		const result = await BaseTransactions.registerManualTransactions(data);

		// Assert
		expect(result).toEqual(transaction);
		Sinon.assert.calledOnce(prisma.transaction.create);
	});

	// Tests that the method creates a transaction with optional fields (currency, date)
	it('should create a transaction with optional fields', async () => {
		// Arrange
		const data = [
			'amount=100;',
			'desc=My description;',
			'method=Mercantil Venezuela;',
			'type=debit;',
			'cat=ENTERTAIMENT;',
			'currency=VES;',
			'date=2022-01-01',
		];
		const transaction = { id: 1, amount: 100, description: 'My description', type: 'debit' };
		prisma.transaction.create = Sinon.stub().resolves(transaction);
		prisma.dailyExchangeRate.findFirst = Sinon.stub().resolves(null);
		prisma.paymentMethod.findUnique = Sinon.stub().resolves({ id: 1 });
		prisma.category.findUnique = Sinon.stub().resolves({ id: 1 });

		// Act
		const result = await BaseTransactions.registerManualTransactions(data);

		// Assert
		expect(result).toEqual(transaction);
		Sinon.assert.calledOnce(prisma.transaction.create);
	});

	// Tests that the method converts VES to USD and creates a transaction
	it('should convert VES to USD and create a transaction', async () => {
		// Arrange
		const data = [
			'amount=100;',
			'desc=My description;',
			'method=Mercantil Venezuela;',
			'type=debit;',
			'cat=Entertaiment;',
			'currency=VES',
		];
		const transaction = { id: 1, amount: 1, description: 'My description', type: 'debit' };
		const exchangeRate = { monitorPrice: 100 };

		// Mock the database methods
		prisma.transaction.create = Sinon.stub().resolves(transaction);
		prisma.dailyExchangeRate.findFirst = Sinon.stub().resolves(exchangeRate);
		prisma.paymentMethod.findUnique = Sinon.stub().resolves({ id: 1 });
		prisma.category.findUnique = Sinon.stub().resolves({ id: 1 });

		// Act
		const result = await BaseTransactions.registerManualTransactions(data);

		// Assert
		expect(result).toEqual(transaction);
		Sinon.assert.calledOnce(prisma.transaction.create);
	});

	// Tests that the method throws an error if any required field is missing
	it('should throw an error if any required field is missing', async () => {
		// Arrange
		const data = ['amount=100;', 'desc=My description;', 'method=Mercantil Venezuela;', 'type=debit;', 'FOOD/HOME'];
		const sampleData =
			'amount=100; desc=My description; method=Mercantil Venezuela; type=debit; cat=CATEGORY_NAME; currency=VES; date=2021-01-01';

		// Act & Assert
		await expect(BaseTransactions.registerManualTransactions(data)).rejects.toThrow(
			`Invalid data: ${data}... Try with ${sampleData}`
		);

		const data1 = ['100;', 'My description;', 'Mercantil Venezuela;', 'debit;', 'FOOD/HOME'];

		await expect(BaseTransactions.registerManualTransactions(data1)).rejects.toThrow(
			`Invalid data: ${data1}... Try with ${sampleData}`
		);
	});

	// Tests that the method throws an error if payment method is not found
	it('should throw an error if payment method is not found', async () => {
		// Arrange
		const data = [
			'amount=100;',
			'desc=My description;',
			'method=Mercantil Venezuela;',
			'type=debit;',
			'cat=ENTERTAIMENT;',
		];

		prisma.paymentMethod.findUnique = Sinon.stub().resolves(null);

		// Act & Assert
		await expect(BaseTransactions.registerManualTransactions(data)).rejects.toThrow(
			'Payment method Mercantil Venezuela not found'
		);
	});

	// Tests that the method throws an error if category is not found
	it('should throw an error if category is not found', async () => {
		// Arrange
		const data = [
			'amount=100;',
			'desc=My description;',
			'method=Mercantil Venezuela;',
			'type=debit;',
			'cat=RANDOM_CATEGORY;',
		];

		prisma.paymentMethod.findUnique = Sinon.stub().resolves({ id: 1 });
		prisma.category.findUnique = Sinon.stub().resolves(null);

		// Act & Assert
		await expect(BaseTransactions.registerManualTransactions(data)).rejects.toThrow(
			'Category RANDOM_CATEGORY not found'
		);
	});
});

// Generated by CodiumAI

describe('registerTransactionFromImages', () => {
	// Given a valid array of text from images, the method should search for a category that matches the keywords in each line and create a transaction with the found category.
	it('should create a transaction with the found category when given a valid array of text from images', async () => {
		// Mock the database module
		const firstArgs = {
			where: {
				categoryKeyword: {
					some: {
						keyword: {
							name: 'my',
						},
					},
				},
			},
		};

		const secondArgs = {
			where: {
				categoryKeyword: {
					some: {
						keyword: {
							name: 'petshop',
						},
					},
				},
			},
		};

		prisma.category.findFirst = Sinon.stub();

		prisma.category.findFirst.withArgs(firstArgs).resolves(null);
		prisma.category.findFirst.withArgs(secondArgs).resolves({ id: 1 });

		prisma.transaction.create = Sinon.stub().resolves({ id: 1 });

		// Mock module PendingTransactionAssignments
		PendingTransactionAssignments.createPendingTransactionAssignment = Sinon.stub().resolves({ id: 1 });

		// Define the input data
		const data = ['my petshop', 'TOTAL   Bs 538.53', 'image text 3'];
		const telegramFileIds = ['file_id_1', 'file_id_2'];

		// Call the method
		const result = await BaseTransactions.registerTransactionFromImages(data, telegramFileIds);

		// Verify the result
		expect(result).toEqual({ transaction: { id: 1 }, category: { id: 1 } });

		// Verify that the database module was called correctly
		Sinon.assert.calledTwice(prisma.category.findFirst);
		Sinon.assert.calledWith(prisma.category.findFirst, firstArgs);
		Sinon.assert.calledWith(prisma.category.findFirst, secondArgs);
		Sinon.assert.calledOnce(prisma.transaction.create);
		Sinon.assert.calledWith(prisma.transaction.create, {
			data: {
				originalCurrencyAmount: 538.53,
				description: 'my petshop TOTAL   Bs 538.53 image text 3',
				type: 'debit',
				date: Sinon.match.date,
				currency: 'VES',
				telegramFileIds: 'file_id_1,file_id_2',
				category: {
					connect: {
						id: 1,
					},
				},
			},
		});

		// Verify that the PendingTransactionAssignments module was not called
		Sinon.assert.notCalled(PendingTransactionAssignments.createPendingTransactionAssignment);
	});

	it('should not create a transaction if there is not amount found. It should throws an error', async () => {
		// Define the input data
		const data = ['my petshop', 'image text 3'];
		const telegramFileIds = ['file_id_1', 'file_id_2'];

		// Call the method
		await expect(BaseTransactions.registerTransactionFromImages(data, telegramFileIds)).rejects.toThrow(
			'Amount not found'
		);
	});

	it('should create the transaction without category and create a task', async () => {
		// Mock the database module
		const firstArgs = {
			where: {
				categoryKeyword: {
					some: {
						keywords: {
							name: 'my',
						},
					},
				},
			},
		};

		const secondArgs = {
			where: {
				categoryKeyword: {
					some: {
						keywords: {
							name: 'petshop',
						},
					},
				},
			},
		};

		prisma.category.findFirst = Sinon.stub();

		prisma.category.findFirst.withArgs(firstArgs).resolves(null);
		prisma.category.findFirst.withArgs(secondArgs).resolves(null);

		prisma.transaction.create = Sinon.stub().resolves({ id: 1 });

		// Mock module PendingTransactionAssignments
		PendingTransactionAssignments.createPendingTransactionAssignment = Sinon.stub().resolves({ id: 1 });

		// Define the input data
		const data = ['my petshop', 'TOTAL   Bs 538.53', 'image text 3'];
		const telegramFileIds = ['file_id_1', 'file_id_2'];

		// Call the method
		const result = await BaseTransactions.registerTransactionFromImages(data, telegramFileIds);

		// Verify the result
		expect(result).toEqual({
			transaction: { id: 1 },
			category: undefined,
		});

		// Verify that the database module was called correctly
		expect(prisma.category.findFirst.callCount).toEqual(10);
		Sinon.assert.calledOnce(prisma.transaction.create);
		Sinon.assert.calledWith(prisma.transaction.create, {
			data: {
				originalCurrencyAmount: 538.53,
				description: 'my petshop TOTAL   Bs 538.53 image text 3',
				type: 'debit',
				telegramFileIds: 'file_id_1,file_id_2',
				date: Sinon.match.date,
				currency: 'VES',
			},
		});

		// Verify that the PendingTransactionAssignments module was called
		Sinon.assert.calledOnce(PendingTransactionAssignments.createPendingTransactionAssignment);
		Sinon.assert.calledWith(PendingTransactionAssignments.createPendingTransactionAssignment, data, 1);
	});

	it('should throw an error if there is not data', async () => {
		// Call the method
		await expect(BaseTransactions.registerTransactionFromImages()).rejects.toThrow('No data found');
	});

	it('should throw an error if there is not telegramFileIds', async () => {
		// Call the method
		await expect(BaseTransactions.registerTransactionFromImages(['data'])).rejects.toThrow('No telegramFileIds found');
	});
});
