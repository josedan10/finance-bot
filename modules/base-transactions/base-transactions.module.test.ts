import { BaseTransactions } from './base-transactions.module';
import Sinon from 'sinon';
import { expect, jest } from '@jest/globals';
import {
	createCategory,
	createDailyExchangeRate,
	createPaymentMethod,
	createTransaction,
} from '../../prisma/factories';
import { prismaMock } from '../database/database.module.mock';
import { Decimal } from '@prisma/client/runtime/library';
import { ExchangeCurrencyCronServices } from '../crons/exchange-currency/exchange-currency.service';

const sandbox = Sinon.createSandbox();

describe('BaseTransactions', () => {
	afterEach(() => {
		sandbox.reset();
		sandbox.restore();
		sandbox.resetHistory();
	});
	// Tests that registerManualTransactions successfully registers a manual transaction with valid data
	it('should successfully register a manual transaction with valid data', async () => {
		// Mock the database methods
		const paymentMethod = await createPaymentMethod({ id: 1 });
		const category = await createCategory({ id: 1 });
		const transaction = await createTransaction({ id: 1 });

		const spyPaymentMethodFindUnique = prismaMock.paymentMethod.findUnique.mockResolvedValue(paymentMethod);
		const spyCategoryFindUnique = prismaMock.category.findUnique.mockResolvedValue(category);
		const spyTransactionCreate = prismaMock.transaction.create.mockResolvedValue(transaction);
		prismaMock.dailyExchangeRate.findFirst.mockResolvedValue(null);

		// Call the registerManualTransactions method
		const data = [
			'amount=100;',
			'desc=My description;',
			'method=Mercantil Venezuela;',
			'type=debit;',
			'cat=Entertaiment',
		];
		await BaseTransactions.registerManualTransactions(data);

		expect(spyPaymentMethodFindUnique).toHaveBeenCalledTimes(1);
		expect(spyTransactionCreate).toHaveBeenCalledTimes(1);
		expect(spyCategoryFindUnique).toHaveBeenCalledTimes(1);
	});

	// Tests that registerManualTransactions successfully registers a manual transaction with minimum data (amount, payment method, type, category)
	it('should successfully register a manual transaction with minimum data', async () => {
		// Mock the database methods
		const paymentMethod = await createPaymentMethod({ id: 1 });
		const category = await createCategory({ id: 1 });
		const transaction = await createTransaction({ id: 1 });

		const spyPaymentMethodFindUnique = prismaMock.paymentMethod.findUnique.mockResolvedValue(paymentMethod);
		const spyCategoryFindUnique = prismaMock.category.findUnique.mockResolvedValue(category);
		const spyTransactionCreate = prismaMock.transaction.create.mockResolvedValue(transaction);
		prismaMock.dailyExchangeRate.findFirst.mockResolvedValue(null);

		// Call the registerManualTransactions method
		const data = [
			'amount=100;',
			'desc=My description;',
			'method=Mercantil Venezuela;',
			'type=debit;',
			'cat=Entertaiment',
		];
		const result = await BaseTransactions.registerManualTransactions(data);

		// Check the result
		expect(result).toEqual(transaction);

		expect(spyPaymentMethodFindUnique).toHaveBeenCalledTimes(1);
		expect(spyTransactionCreate).toHaveBeenCalledTimes(1);
		expect(spyCategoryFindUnique).toHaveBeenCalledTimes(1);
	});
});

// Generated by CodiumAI

describe('registerManualTransactions', () => {
	// Tests that the method creates a transaction with all required fields
	it('should create a transaction with all required fields', async () => {
		// Arrange
		const data = [
			'amount=100;',
			'desc=My description;',
			'method=Mercantil Venezuela;',
			'type=debit;',
			'cat=ENTERTAIMENT',
		];
		const paymentMethod = await createPaymentMethod({ id: 1 });
		const category = await createCategory({ id: 1 });
		const transaction = await createTransaction({ id: 1, amount: 100, description: 'My description', type: 'debit' });

		// uses sinon to mock the database methods
		const spyPaymentMethodFindUnique = prismaMock.paymentMethod.findUnique.mockResolvedValue(paymentMethod);
		const spyCategoryFindUnique = prismaMock.category.findUnique.mockResolvedValue(category);
		const spyTransactionCreate = prismaMock.transaction.create.mockResolvedValue(transaction);
		prismaMock.dailyExchangeRate.findFirst.mockResolvedValue(null);

		// Act
		const result = await BaseTransactions.registerManualTransactions(data);

		// Assert
		expect(result).toEqual(transaction);
		expect(spyTransactionCreate).toHaveBeenCalledTimes(1);
		expect(spyCategoryFindUnique).toHaveBeenCalledTimes(1);
		expect(spyPaymentMethodFindUnique).toHaveBeenCalledTimes(1);
	});

	// Tests that the method creates a transaction with optional fields (currency, date)
	it('should create a transaction with optional fields', async () => {
		// Arrange
		const data = [
			'amount=100;',
			'desc=My description;',
			'method=Mercantil Venezuela;',
			'type=debit;',
			'cat=ENTERTAIMENT;',
			'currency=VES;',
			'date=2022-01-01',
		];
		const paymentMethod = await createPaymentMethod({ id: 1 });
		const category = await createCategory({ id: 1 });
		const transaction = await createTransaction({ id: 1, amount: 100, description: 'My description', type: 'debit' });

		const spyPaymentMethodFindUnique = prismaMock.paymentMethod.findUnique.mockResolvedValue(paymentMethod);
		const spyCategoryFindUnique = prismaMock.category.findUnique.mockResolvedValue(category);
		const spyTransactionCreate = prismaMock.transaction.create.mockResolvedValue(transaction);
		prismaMock.dailyExchangeRate.findFirst.mockResolvedValue(null);

		// Act
		const result = await BaseTransactions.registerManualTransactions(data);

		// Assert
		expect(result).toEqual(transaction);
		expect(spyTransactionCreate).toHaveBeenCalledTimes(1);
		expect(spyCategoryFindUnique).toHaveBeenCalledTimes(1);
		expect(spyPaymentMethodFindUnique).toHaveBeenCalledTimes(1);
	});

	// Tests that the method converts VES to USD and creates a transaction
	it('should convert VES to USD and create a transaction', async () => {
		// Arrange
		const data = [
			'amount=100;',
			'desc=My description;',
			'method=Mercantil Venezuela;',
			'type=debit;',
			'cat=Entertaiment;',
			'currency=VES',
		];

		const paymentMethod = await createPaymentMethod({ id: 1 });
		const category = await createCategory({ id: 1 });
		const transaction = await createTransaction({ id: 1, amount: 1, description: 'My description', type: 'debit' });
		const exchangeRate = await createDailyExchangeRate({ monitorPrice: 100 });

		// Mock the database methods
		const spyPaymentMethodFindUnique = prismaMock.paymentMethod.findUnique.mockResolvedValue(paymentMethod);
		const spyCategoryFindUnique = prismaMock.category.findUnique.mockResolvedValue(category);
		const spyTransactionCreate = prismaMock.transaction.create.mockResolvedValue(transaction);
		prismaMock.dailyExchangeRate.findFirst.mockResolvedValue(exchangeRate);

		// Act
		const result = await BaseTransactions.registerManualTransactions(data);

		// Assert
		expect(result).toEqual(transaction);
		expect(spyTransactionCreate).toHaveBeenCalledTimes(1);
		expect(spyCategoryFindUnique).toHaveBeenCalledTimes(1);
		expect(spyPaymentMethodFindUnique).toHaveBeenCalledTimes(1);
	});

	// Tests that the method throws an error if any required field is missing
	it('should throw an error if any required field is missing', async () => {
		// Arrange
		const data = ['amount=100;', 'desc=My description;', 'method=Mercantil Venezuela;', 'type=debit;', 'FOOD/HOME'];
		const sampleData =
			'amount=100; desc=My description; method=Mercantil Venezuela; type=debit; cat=CATEGORY_NAME; currency=VES; date=2021-01-01';

		// Act & Assert
		await expect(BaseTransactions.registerManualTransactions(data)).rejects.toThrow(
			`Invalid data: ${data}... Try with ${sampleData}`
		);

		const data1 = ['100;', 'My description;', 'Mercantil Venezuela;', 'debit;', 'FOOD/HOME'];

		await expect(BaseTransactions.registerManualTransactions(data1)).rejects.toThrow(
			`Invalid data: ${data1}... Try with ${sampleData}`
		);
	});

	// Tests that the method throws an error if payment method is not found
	it('should throw an error if payment method is not found', async () => {
		// Arrange
		const data = [
			'amount=100;',
			'desc=My description;',
			'method=Mercantil Venezuela;',
			'type=debit;',
			'cat=ENTERTAIMENT;',
		];

		prismaMock.paymentMethod.findUnique.mockResolvedValue(null);

		// Act & Assert
		await expect(BaseTransactions.registerManualTransactions(data)).rejects.toThrow(
			'Payment method Mercantil Venezuela not found'
		);
	});

	// Tests that the method throws an error if category is not found
	it('should throw an error if category is not found', async () => {
		// Arrange
		const data = [
			'amount=100;',
			'desc=My description;',
			'method=Mercantil Venezuela;',
			'type=debit;',
			'cat=RANDOM_CATEGORY;',
		];

		const paymentMethod = await createPaymentMethod({ id: 1 });

		prismaMock.category.findUnique.mockResolvedValue(null);
		prismaMock.paymentMethod.findUnique.mockResolvedValue(paymentMethod);

		// Act & Assert
		await expect(BaseTransactions.registerManualTransactions(data)).rejects.toThrow(
			'Category RANDOM_CATEGORY not found'
		);
	});
});

// Generated by CodiumAI

describe('registerTransactionFromImages', () => {
	// Given a valid array of text from images, the method should search for a category that matches the keywords in each line and create a transaction with the found category.
	it('should create a transaction with the found category when given a valid array of text from images', async () => {
		// Mock the database module
		const firstArgs = {
			where: {
				categoryKeyword: {
					some: {
						keyword: {
							name: 'my',
						},
					},
				},
			},
		};

		const secondArgs = {
			where: {
				categoryKeyword: {
					some: {
						keyword: {
							name: 'petshop',
						},
					},
				},
			},
		};

		const transaction = await createTransaction({ id: 1 });
		const category = await createCategory({ id: 1 });

		const spyCategoryFindFirst = prismaMock.category.findFirst
			.mockResolvedValueOnce(null)
			.mockResolvedValueOnce(category);

		prismaMock.dailyExchangeRate.findFirst.mockResolvedValue(null);
		const spyTransactionCreate = prismaMock.transaction.create.mockResolvedValue(transaction);

		// Define the input data
		const data = ['my petshop', 'TOTAL   Bs 538.53', 'image text 3'];
		const telegramFileIds = ['file_id_1', 'file_id_2'];

		// Call the method
		const result = await BaseTransactions.registerTransactionFromImages(data, telegramFileIds);

		// Verify the result
		expect(result.transaction.id).toEqual(1);
		expect(result.category?.id).toEqual(1);

		// Verify that the database module was called correctly
		expect(spyCategoryFindFirst).toHaveBeenCalledTimes(2);
		expect(spyTransactionCreate).toHaveBeenCalledTimes(1);
		expect(spyCategoryFindFirst).toBeCalledWith(firstArgs);
		expect(spyCategoryFindFirst).toBeCalledWith(secondArgs);
		expect(spyTransactionCreate).toHaveBeenCalledWith({
			data: {
				originalCurrencyAmount: 538.53,
				description: 'my petshop TOTAL   Bs 538.53 image text 3',
				type: 'debit',
				currency: 'VES',
				telegramFileIds: 'file_id_1,file_id_2',
				date: expect.any(Date),
				category: {
					connect: {
						id: 1,
					},
				},
			},
		});
	});

	it('should not create a transaction if there is not amount found. It should throws an error', async () => {
		// Define the input data
		const data = ['my petshop', 'image text 3'];
		const telegramFileIds = ['file_id_1', 'file_id_2'];

		// Call the method
		await expect(BaseTransactions.registerTransactionFromImages(data, telegramFileIds)).rejects.toThrow(
			'Amount not found'
		);
	});

	it('should create the transaction without category and create a task', async () => {
		const spyCategoryFindFirst = prismaMock.category.findFirst.mockResolvedValue(null);

		prismaMock.dailyExchangeRate.findFirst.mockResolvedValue(null);

		const transaction = await createTransaction({ id: 1 });

		const spyTransactionCreate = prismaMock.transaction.create.mockResolvedValue(transaction);

		// Define the input data
		const data = ['my petshop', 'TOTAL   Bs 538.53', 'image text 3'];
		const telegramFileIds = ['file_id_1', 'file_id_2'];

		// Call the method
		const result = await BaseTransactions.registerTransactionFromImages(data, telegramFileIds);

		// Verify the result
		expect(result.transaction.id).toEqual(1);
		expect(result.category).toEqual(null);

		// Verify that the database module was called correctly
		expect(spyCategoryFindFirst).toHaveBeenCalledTimes(10);
		expect(spyTransactionCreate).toHaveBeenCalledTimes(1);
		expect(spyTransactionCreate).toHaveBeenCalledWith({
			data: {
				originalCurrencyAmount: 538.53,
				description: 'my petshop TOTAL   Bs 538.53 image text 3',
				type: 'debit',
				telegramFileIds: 'file_id_1,file_id_2',
				date: expect.any(Date),
				currency: 'VES',
			},
		});
	});
});

describe('_VESToUSDWithExchangeRateByDate', () => {
	it("should convert VES to USD using the current exchange rate where the transaction date is different to today's date", async () => {
		ExchangeCurrencyCronServices.getLatestExchangeCurrency = jest.fn(async () => 100 as unknown as Decimal);

		// Call the method
		const result = await BaseTransactions._VESToUSDWithExchangeRateByDate('2022-01-01', 100);

		// Verify the result
		expect(result).toEqual(1.0);
	});

	it("should convert VES to USD using the current exchange rate where the transaction date is the same as today's date", async () => {
		ExchangeCurrencyCronServices.getLatestExchangeCurrency = jest.fn(async () => 100 as unknown as Decimal);

		jest.useFakeTimers().setSystemTime(new Date('2022-01-01').getTime());

		// Call the method
		const result = await BaseTransactions._VESToUSDWithExchangeRateByDate('2022-01-01', 100);

		// Verify the result
		expect(result).toEqual(1.0);
	});

	it('should return null if the exchange rate is not found', async () => {
		// Mock the database module
		ExchangeCurrencyCronServices.getLatestExchangeCurrency = jest.fn(async () => null);

		// Call the method
		const result = await BaseTransactions._VESToUSDWithExchangeRateByDate('2022-01-01', 100);

		// Verify the result
		expect(result).toEqual(null);
	});

	it('should return a value if the date is weekend day', async () => {
		// Mock the database module
		jest.useFakeTimers().setSystemTime(new Date('2024-03-03').getTime());
		ExchangeCurrencyCronServices.getLatestExchangeCurrency = jest.fn(async () => 100 as unknown as Decimal);

		// Call the method with a weekend date
		const result = await BaseTransactions._VESToUSDWithExchangeRateByDate('2024-03-03', 100);

		// Verify the result
		expect(result).toEqual(1.0);
	});

	it('should return a value if the execution hour is before 9:00 or after 11:00', async () => {
		// Mock the database module
		jest.useFakeTimers().setSystemTime(new Date('2024-03-05T08:59:59').getTime());
		ExchangeCurrencyCronServices.getLatestExchangeCurrency = jest.fn(async () => 100 as unknown as Decimal);

		// Call the method with a weekday date
		const result = await BaseTransactions._VESToUSDWithExchangeRateByDate('2024-03-05', 100);
		expect(result).toEqual(1.0);

		jest.useFakeTimers().setSystemTime(new Date('2024-03-05T11:00:01').getTime());

		// Call the method with a weekday date
		const result2 = await BaseTransactions._VESToUSDWithExchangeRateByDate('2024-03-05', 100);

		expect(result2).toEqual(1.0);
	});
});
